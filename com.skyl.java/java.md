### Java
+ 平台无关性
    1. Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令

#### Java 异常体系 
   + Error 和 Exception的区别。 前者是程序无法处理的错误，后者是可以处理的异常。
   + Erro 是需要JVM 需要识别出的。RuntimeException是程序应该负担的责任。Checked Exception可检查异常是Java编译器应该负担的责任。
   + Java的异常机制
       1. 抛出异常：创建异常对象，交由运行时系统处理
       2. 捕获异常：寻找合适的异常处理器   
   + 异常处理原则：
       1. 具体明确：抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因
       2. 提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题。
       3. 延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常
#### Java 基础数据结构
   + HashMap: 数组+链表+红黑树
      + put方法的逻辑
         1. 如果hashmap未被初始化过，则初始化
         2. 对key求hash值，然后计算下表
         3. 如果有没有碰撞，直接放入桶中
         4. 如果碰撞了，以链表方式链接到后面
         5. 如果链表长度超过阈值，就把链表转成红黑树
         6. 如果链表长度低于6，就把红黑树转回链表
         7. 如果节点已经存在就替换旧值
         8. 如果桶满了，就需要resize.
      + 如何有效减少碰撞
         1. 扰动函数：促使元素位置分布均与，减少碰撞几率
         2. 使用final对象，并采用合适的equal() 和 hashcode方法 
      + 扩容的问题
         1. 多线程环境下，调整大小会存在条件竞争，容易造成死锁
         2. rehashing是一个比较耗时的过程
   + CoucurrentHashMap。CAS + synchronized 使锁细化
      + put方法的逻辑
        1. 判断node数组是否初始化，没有则进行初始化操作
        2. 通过hash定位数组的索引坐标，是否有node节点，如果没有则使用CAS进行添加，添加失败则进入下次循环
        3. 检查到内部正在扩容，就帮助它一块扩容
        4. 如果f !=null,则使用synchronized锁住f元素
            1. 如果是node则执行链表的添加操作
            2. 如果是treenode则执行树的添加操作
        5. 判断链表长度已经达到临界值8，当然这个8是默认值，大家也可以去做调整，当节点数超过这个值就需要把链表转换为树结构
      + 总结
        1. 首先使用无所操作CAS插入头节点，失败则循环重试
        2. 若头节点已存在，则尝试获取头节点的同步锁，再进行操作
   +  HashMap,HashTabel,CoucurrentHashMap
       1. HashMap线程不安全，数组+链表+红黑树
       2. HashTable 线程安全，锁住整个对象，数组+链表
       3. ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树
#### Java IO 体系
  + BIO : InputStream OutputStream Reader 和Writer. 同步阻塞 
  + NIO : 构建多路复用的，同步非阻塞IO 操作。 Channels，Buffer，Selectors
  + AIO : 基于时间和回调机制
    1. 基于回调：实现completionHandler接口，调用时触发回调函数
    2. 返回future:通过isDone()查看是否准备好，通过get（）等待返回数据。异步非阻塞 
#### Java 流 
  + 什么是流 。 流是随着时间产生的数据序列。
     1. 支持函数式编程
     2. 提供管道运算能力
     3. 提供并发计算能力
     4. 提供大量的操作
  + 流的并行计算
     1. 流经过parallel或者parallelStream运算之后，内部会创建ForkJoinPool组织并行计算。通常是以CPU核数-1数量创建线程。也可以自己提供ForkJoinPool。
  + [Monad](https://www.ruanyifeng.com/blog/2015/07/monad.html)。是一个自函子范畴上的一个幺半群
     1. 目标：构造流计算（管道计算）
     2. 特点 （泛型类型不变是构造流计算的基石）
         1. 一个泛型的构造函数，比如 Optional 
         2. 不改变泛型类型的运算操作，内部是非泛型计算
         3. 泛型类型不变，比如可以是Optional<Integer>到Optional<String>，但还是Optional<T>类型
     3. 实战使用。多条SQL比对。进行数据库的搜索结果的对比
#### 缓冲区
  + 流 vs 缓冲区：流要随着时间到来的数据。缓存区：缓冲作用。
  + 概念： Buffer 。FIFO 。
  + 作用：排队处理，批量处理。
  + 缓冲区实现原理： 数组和链表。
  + 缓冲区操作：
    1. flip（反转，将position设置为0，limit设置为position的位置） 
    2. clear （当缓冲区使用完可以进行清空。清空操作将缓冲区恢复到初始状态。）
    3. rewind （有时候我们需要重新读取流中的数据。这个时候，就像倒带（rewind）一样，需要将position置0，其他不变）
  + 缓冲区中文处理（缓存大小设置导致中文乱码）
  + 缓存区大文件频词统计 
#### Java 反射
  + 概念：运行时查看，反观程序内部结构，甚至修改