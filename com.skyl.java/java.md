### Java
+ 平台无关性
    1. Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令
+ 类从编译到执行的过程
    1. 编译器将Robot.java源文件编译为Robot.class字节码文件。
    2. ClassLoader 将字节码转换为JVM中的Class<Robot>对象
    3. JVM利用Class<Robot>对象实例化为Robot对象
####  JVM
   1. classloader:依据特定格式，加载class文件到内存
        + ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。
        + 种类
            1. BootStrapClassLoader ：加载核心库 
            2. ExtClassLoader ： 加载扩展库
            3. AppClassLoader:   加载程序所在目录
            4. 自定义ClassLoader : 定制化加载 
        + 双亲委派机制
            1. 自底向上检查类是否已经加载
            2. 自顶向下尝试加载类 
                1. BootstrpClassLoader
                2. ExtensinClassLoader
                3. AppClassLoader
                4. CustomClassLoader
   2. Execution Engine: 对命令进行解析 
   3. Native Interface ：融合不同开发语言的原生库为java所用
   4. Runtime data Area： jvm 内存运行模型
        + 线程私有：程序计数器，虚拟机栈，本地方法栈
            1. 程序计数器
                1. 当前线程所执行的字节码行号指示器
                2. 改变计数器的值来选取下一条需要执行的字节码指令
                3. 和线程是一对一的关系即线程私有
                4. 对Java方法计数，如果是Native方法则计数器值为undefined
                5. 不会发生内存泄漏
            2. Java虚拟机栈
                1. Java方法执行的内存模型
                2. 包含多个栈帧
                    1. 局部变量表：包含方法执行过程中的所有变量
                    2. 操作栈：入栈、出栈、复制、交换、产生消费变量
                    3. 动态链接
                    4. 返回地址
       +  线程共享：MetaSpace,Java堆 
            + MetaSpace 和 PermGen的对比 及 优势 
                1. 元空间使用本地内存，而永久代使用的是jvm的内存
                2. 字符串常量池存在永久代中，容易出现性能问题和内存溢出
                3. 类和方法的信息的大小难以确定，给永久代的大小制定带来困难
                4. 永久代会为GC带来不必要的确定性
                5. 方便hotspot 与其他JVM 如Jrockit的集成
            + Java堆（heap）
                1. 对象实例的分配区域
                2. GC管理的主要区域
   + JVM 三大性能调优参数 -Xms -Xmx -Xss的含义
        1. -Xss : 规定了每个线程虚拟机栈的大小
        2. -Xms : 堆的初始值
        3. -Xmx : 堆能达到的最大值
   + Java内存模型JMM
        1. 主内存
            1. 存储java实例对象
            2. 包括成员变量、类信息、常量、静态变量等
            3. 属于数据共享的区域，多线程并发操作时会引发线程安全问题
        2. 工作内存
            1. 存储当前方法的所有本地变量信息，本地变量对其他线程不可见
            2. 字节码行号指示器，natvie方法信息
            3. 属于线程私有数据区域，不存在线程安全问题
   + Java内存模型中堆和栈的区别—内存分配策略
        1. 静态存储：编译时确定每个数据目标在运行时的存储空间要求
        2. 栈式存储：数据区要求在编译时未知，运行时模块入口前确定
        3. 堆式存储：编译时或者运行时或运行时模块入口都无法确定，动态分配
   + Java内存模型中堆和栈的区别
        1. 联系：引用对象、数组时，栈里定义变量保存堆中目标的首地址
        2. 区别
            1. 管理方式：栈自动释放，堆需要GC
            2. 空间大小：栈比堆小
            3. 碎片相关：栈产生的碎片远小于堆
            4. 分配方式：栈支持静态和动态分配，而堆仅支持动态分配
            5. 效率：栈的效率比堆高
   + 元空间、堆、线程独占部分空间的联系—内存角度
        1. 元空间：Class: hellword - method:sayHello - field:name  Class:System
        2. Java堆：Object : String ('test') Object : HelloWorld
        3. 线程独占：Parameter reference: test to String object 。 Variable reference : hw to helloword object .Local Variables: a with 1 lineNo
   + 垃圾回收机制      
        + 判定对象是否为垃圾的算法
            1. 引用计数算法 ：通过判断对象的引用数量决定对象是否可以被回收，被引用+1，完成引用-1
            2. 可达性算法：通过判断对象的引用链是否可达来决定对象是否可以被回收
        + 垃圾回收算法
            1. 标记-清除算法
                1. 标记：从根基和进行扫描，对存货的对象进行标记
                2. 清除：对堆内存从头到尾进行线性遍历，回收不可达对象内存
            2. 复制算法: 解决碎片化的问题，顺序分配内存简单高效，适用于对象存活低的场景
                1. 分为对象面和空闲面
                2. 对象在对象面上创建
                3. 存活的对象被从对象面复制到空闲面
                4. 将对象面所有对象内存清除 
            3. 标记-整理算法：避免内存的不连续行，不用设置两块内存互换，适用于对象存活率高的场景
                1. 标记： 从根集合进行扫描，对存活得对象进行标记
                2. 清除： 移动所有存活的对象，且按照内存地址次序依次排列，然后将末端内存地址以后的内存全部回收
            4. 分代收集算法
                1. Minor GC : 年轻代（尽快收集生命周期短的对象），采用复制算法
                    1. 收集器分类
                        1. Serial 收集器 。复制算法，单线程收集。简单高效，Client模式下默认运行的年轻收集器
                        2. ParNew收集器。 复制算法，单核执行效率不如Serial。
                        3. Parallel Scavenge 收集器。 复制算法。多线程收集，更关注系统的吞吐量。Server模式下默认的年轻收集器
                2. Full GC : 老年代（经历一次Minor次数依然存活的对象)，采用标记清理或标记整理算法
                    1. 触发条件
                        1. 老年代空间不足
                        2. 永久代空间不足
                        3. CMS GC出现promotion failed，cocurrent mode failure
                        4. Minor GC晋升到老年代的平均大小 大于老年代的剩余空间
                        5. 调用System.gc()
                    2. 收集器分类
                        1. Serial Old 收集器 。标记整理算法。单线程收集，进行垃圾收集时，Client模式下默认的老年代收集器
                        2. Parallel Old 收集器。标记整理算法。 多线程收集，吞吐量优先。
                        3. CMS 收集器。（标记 清除算法）
                        4. Garbage First 收集器。复制+标记-整理算法。并行并发。分代收集。空间整合。可预测的停顿。
                            1. 将整个Java堆内存划分成多个大小相等的Region
                            2. 年轻代和老年代不再物理隔离 
            5. 常用的调优参数
                1. -XX:SuviorRatio:Eden和Survivor的比值：默认8：1
                2. -XX：NewRation:老年代和年轻代内存大小的比例
                3. -XX:MaxTenuringThreshold：对象从年轻晋升到老生代经过GC次数的最大阀值
   + Object的finalize()方法的作用是否与C++的析构函数作用相同
        1. 与C++的析构函数不同，析构函数调用确定，而它的是不确定的。
        2. 将未被引用的对象放置于F-Queue队列
        3. 方法执行随时可能会被终止
        4. 给予对象最后一次重生的机会
   + Java中的强引用，软引用，弱引用，虚引用有什么用
        1. 强引用
        2. 软引用：可以用来实现高速缓存
        3. 弱引用: 适用于偶尔被使用且不影响垃圾收集的对象
        4. 虚拟用：跟踪对象被垃圾回收器回收的活动，起到哨兵作用
####　Java进程 线程 并发 
   + 进程与线程。  进程是资源分配的最小单位，线程是CPU调度的最小单位
        + 区别
            1.  线程不能看作独立应用，进程可以看作独立应用
            2.  进程有独立的地址空间，相互不影响，线程只是进程的不同执行路径
            3.  线程没有独立的地址空间，多进程的程序比多线程程序健壮
            4.  进程的切换比线程的切换开销大。
        + Java中两者的关系
            1. Java对操作系统提供的功能进行封装，包括进程和线程
            2. 运行一个程序会产生一个进程，进程包含至少一个线程
            3. 每个进程对应一个JVM实例，多个线程共享JVM里的堆
            4. Java采用单线程编程模型，程序会自动创建主线程
            5. 主线程可以创建子线程，原则上要后于子线程完成执行
   + Thread中start 和 run方法的区别
        1. 调用start（）方法会创建一个新的子线程启动
        2. run（）方法只是Thread中的一个普通方法的调用
   + Thread 和Runnabale是什么关系
        1. Thread是实现了Runnble接口的类，使得run支持多线程
        2. 因类的单一继承原则，推荐多使用Runnable接口
   + 如何实现处理线程的返回值
        1. 主线程等待法，直到等到子线程返回结果
        2. 使用Thread类的join()阻塞当前线程以等待子线程处理完毕
        3. 通过callble接口实现：通过FutureTask Or 线程池获取
   + 线程的状态
        1. 新建 new ： 创建后尚未启动的线程状态
        2. 运行（Runnable） :包含Running 和Ready
        3. 无限期等待 waiting：不会被分配CPU执行时间，需要显式被唤醒
        4. 限期等待  timed wating : 在一定时间后由系统自动唤醒
        5. 阻塞 blocked: 等待获取排他锁
        6. 结束： 已终止线程的状态，线程已经结束执行
   + sleep 和wait的区别
     1. sleep 是Thread类的方法，wait是object类中定义的方法
     2. sleep方法可以在任何地方使用
     3. wait方法只能在synchronized 方法 或 synchronized块中使用
     4. Thread.sleep只会让出CPU，不会导致锁行为的改变
     5. Object.wait不仅让出CPU，还会释放已经占有的同步资源锁
   + notify 和 notifyall的区别
     1. notifyall会让所有处于等待池的线程全部进入锁池去竞争获取锁的机会
     2. notify只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会
   + yield。调用Thread.yield()函数时，会给线程调度器一个当前线程愿意让出CPU使用的暗示。
   + interrupt 函数。调用此函数，通知线程应该中断了。
     1. 如果线程处于被阻塞状态，那么线程将立即退出被阻塞状态，并抛出一个异常
     2. 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true。被设置中断标志的线程将继续正常运行，不受影响。
   + synchronized 互斥锁
     1. 特性
        1. 互斥性：即在同一时间只允许一个线程持有某个对象锁，通过这种特性，来实现多线程的协调机制，这样在同一个时间内只有一个线程对需要同步的代码块进行访问
        2. 可见性：必须确保在锁被释放之前，对共享变量所做的修改，对于随后获得该锁的另一个线程是可见的，否则另一个线程可能是在本地缓存的某个副本上继续操作，可能引起不一致
     2. 根据获取的锁分类：获取对象锁和获取类锁
        1. 获取对象锁的两种用法
            1. 同步代码块（synchronized(this),synchronized(类实例对象)），锁是小括号（）中的实例对象
            2. 同步非静态方法（synchronized method）,锁是当前对象的实例对象
        2. 获取类锁的两种方法
            1. 同步代码块（synchronzed(类.class)）,锁是小括号（）中的类对象（class 对象）。
            2. 同步静态方法（synchronized static method ）,锁是当前对象的类对象（class 对象）。
     3. 四种状态
        1. 无锁
        2. 偏向锁 （更偏向之前获取过锁的线程，省去再次进入的锁申请）：减少同一线程获取锁的代价。大多数情况下，锁不存在多线程竞争，总是由同一线程多次获得
        3. 轻量级锁 （由偏向锁升级）： 偏向锁在运行一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁。
        4. 重量级锁
     4. synchronized 和 reentrantlock的区别
        1. Reentrantlock 实现比 synchronized 更细粒度的控制。调用lock后，必须调用unlock释放锁。
        2. Reentrantlock 公平性，倾向于将锁赋予等待时间最久的线程。synchronized 是非公平锁
        3. synchronized 是关键字，Reentrantlock 是类
        4. Reentrantlock 可以对锁的等待时间进行设置，避免死锁
        5. Reentrantlock 可以获取各种锁的信息
        6. Reentrantlock 可以灵活地实现多路通知
        7. 机制：sync 操作Mark Word ，lock 调用unsafe类的park（）方法
     5. synchronized 和 volatile的区别
        1. volatile 本质是告诉JVM 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住直到该线程完成变量操作为止
        2. volatile 仅能使用在变量级别；synchronized 则可以使用在变量、方法和类级别
        3. volatile 仅能实现变量的修改可见性，不能保证原子性，而synchronized则可以保证变量比修改的的可见性和原子性
        4. volatile 不会造成线程的阻塞：synchronized可能会造成线程的阻塞
        5. volatile 标记的变量不会被编译优化；synchronized标记的变量可以被编译器优化
   + 自旋锁和自适应自旋锁
      1. 自旋锁
        1. 许多情况下，共享数据的锁定状态持续时间较短，切换线程不值得
        2. 通过让线程执行忙循环等待锁的释放，不让出CPU
        3. 缺点：若锁被其他线程长时间占用，会带来许多性能上的开销
      2. 自适应自旋锁
        1. 自旋的次数不再固定
        2. 由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定
   + 锁消除: JIT编译时，对运行上下文进行扫描，去除不可能存在竞争的锁。‘
   + 锁粗化：通过扩大加锁的范围，避免反复加锁和解锁
   + CAS。（线程安全程序的首选）
      1. 特性
        1. 支持原子更新操作，适用于计数器，序列发生器等场景
        2. 属于乐观锁机制，
        3. CAS操作失败时，由开发者决定是否继续尝试，还是执行别的操作
        4. unsafe类虽提供CAS服务，但因能够操纵任意内存地址读写而有隐患
        5. java9 以后，可以使用variable handle api 来替代unsafe.
      2. 缺点
        1. 若循环时间过长，则开销很大
        2. 只能保证一个共享变量的原子操作
        3. ABA 问题 。 解决：AtmoicStampleReference 
   + Java线程池 。 降低资源消耗，提供线程的可管理性
      + Fork/Join框架。work-stealing算法：某个线程从其他队列窃取任务来执行
         1. 把大任务分割成若个小人物并行执行，最终汇总每个小任务结果后得到大任务结果的框架。 
      + 三个Executor接口
         1. Executor: 运行新任务的简单接口，将任务提交爱哦和任务执行细节解耦
         2. ExecutorService: 具备管理执行器和任务周期的方法，提交任务机制更完善
         3. ScheduledExecutorService: 支持Future和 定期执行任务。
      + handler ： 线程池的饱和策略
         1. AbortPolicy:直接抛出异常，这是默认策略
         2. CallerRunPolicy:用调用者所在的线程来执行任务
         3. DiscardOldestPolicy:丢弃队列中最靠前的任务，并执行当前任务
         4. DiscardPolicy : 直接丢弃任务
         5. 实现RejectedExecutionHandler接口的自定义Handler
      + 线程池的状态
         1. RUNNING:能接受新提交的任务，并且也能处理阻塞队列中的任务
         2. SHUTDOWN:不再接受新提交的任务，但可以处理存量任务
         3. STOP : 不再接受新提交的任务，也不处理存量任务
         4. TIDING： 所有的任务都已终止。
         5. TERMINATED : teminated()方法执行后进入该状态
      + 线程池大小的选定
         1. CPU 密集型： 线程数 = 按照核数 或者 核数+1 设定
         2. I/O 密集型 ： 线程数 = CPU核数（1 + 平均等待时间/平均工作时间）
   + 并发工具类
       + 闭锁 CountDownLatch  让主线程等待一组事件发生后继续执行
       + 栅栏 CyclicBarrier  阻塞当前线程，等待其他线程。
       + 信号量 Semaphore 控制某个资源可以被同时访问的线程个数 
       + 交换器 Exchanger  两个线程到达同步点后，相互交换数据
#### Java 异常体系 
   + Error 和 Exception的区别。 前者是程序无法处理的错误，后者是可以处理的异常。
   + Erro 是需要JVM 需要识别出的。RuntimeException是程序应该负担的责任。Checked Exception可检查异常是Java编译器应该负担的责任。
   + Java的异常机制
       1. 抛出异常：创建异常对象，交由运行时系统处理
       2. 捕获异常：寻找合适的异常处理器   
   + 异常处理原则：
       1. 具体明确：抛出的异常应能通过异常类名和message准确说明异常的类型和产生异常的原因
       2. 提早抛出：应尽可能早的发现并抛出异常，便于精确定位问题。
       3. 延迟捕获：异常的捕获和处理应尽可能延迟，让掌握更多信息的作用域来处理异常
#### Java 基础数据结构
   + HashMap: 数组+链表+红黑树
      + put方法的逻辑
         1. 如果hashmap未被初始化过，则初始化
         2. 对key求hash值，然后计算下表
         3. 如果有没有碰撞，直接放入桶中
         4. 如果碰撞了，以链表方式链接到后面
         5. 如果链表长度超过阈值，就把链表转成红黑树
         6. 如果链表长度低于6，就把红黑树转回链表
         7. 如果节点已经存在就替换旧值
         8. 如果桶满了，就需要resize.
      + 如何有效减少碰撞
         1. 扰动函数：促使元素位置分布均与，减少碰撞几率
         2. 使用final对象，并采用合适的equal() 和 hashcode方法 
      + 扩容的问题
         1. 多线程环境下，调整大小会存在条件竞争，容易造成死锁
         2. rehashing是一个比较耗时的过程
   + CoucurrentHashMap。CAS + synchronized 使锁细化
      + put方法的逻辑
        1. 判断node数组是否初始化，没有则进行初始化操作
        2. 通过hash定位数组的索引坐标，是否有node节点，如果没有则使用CAS进行添加，添加失败则进入下次循环
        3. 检查到内部正在扩容，就帮助它一块扩容
        4. 如果f !=null,则使用synchronized锁住f元素
            1. 如果是node则执行链表的添加操作
            2. 如果是treenode则执行树的添加操作
        5. 判断链表长度已经达到临界值8，当然这个8是默认值，大家也可以去做调整，当节点数超过这个值就需要把链表转换为树结构
      + 总结
        1. 首先使用无所操作CAS插入头节点，失败则循环重试
        2. 若头节点已存在，则尝试获取头节点的同步锁，再进行操作
   +  HashMap,HashTabel,CoucurrentHashMap
       1. HashMap线程不安全，数组+链表+红黑树
       2. HashTable 线程安全，锁住整个对象，数组+链表
       3. ConcurrentHashMap线程安全，CAS+同步锁，数组+链表+红黑树
#### Java IO 体系
  + BIO : InputStream OutputStream Reader 和Writer. 同步阻塞 
  + NIO : 构建多路复用的，同步非阻塞IO 操作。 Channels，Buffer，Selectors
  + AIO : 基于时间和回调机制
    1. 基于回调：实现completionHandler接口，调用时触发回调函数
    2. 返回future:通过isDone()查看是否准备好，通过get（）等待返回数据。异步非阻塞 
     
  