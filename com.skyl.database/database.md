### 数据库
+ 如何设计一个数据库
    +   程序实例
        +  存储管理
        +  缓存机制
        +  SQL解析
        +  日志管理
        +  权限划分
        +  容灾机制
        +  索引管理
            1. 为什么使用索引 -> 快速查询数据，不再使用全表扫描
            2. 什么信息能成为索引 ->  主键，唯一键，普通键
            3. 索引相关
                + 索引相关数据结构
                    1. 二叉查找树，有风险退化成链表
                    2. B-Tree
                    3. B+-Tree 磁盘读写代价低，查询效率更稳定，更有利于数据库的扫描
                    4. Hash索引 
                        + 优点
                            1. 查询效率高
                        + 缺点
                            1. 不能使用范围查询
                            2. 无法使用排序操作
                            3. 不能利用组合索引键进行查询
                            4. 不能避免表扫描
                +  密集索引和稀疏索引
                      1.  密集索引文件中的每个搜索码值都对应一个索引值
                      2.  稀疏索引文件只为索引码的某些值建立索引项
                +  如何定位并优化慢查询sql
                      1. 根据慢日志查询sql
                      2. 使用explain等工具分析sql
                      3. 修改sql或者尽量让sql走索引 
        +  锁管理
            1. MyIsam 与 Innodb 关于锁方面的区别是什么
                1. MyIsam 默认为表级锁，不支持行级锁
                    +  MyIsam 适用场景
                        1. 频繁执行全表count语句
                        2. 对数据进行增删改的频率不高，查询非常频繁
                        3. 没有事务
                2. InnoDB默认用的是行级锁，也支持表级锁
                    + InnoDB适合的场景
                        1. 数据增删改查相当频繁
                        2. 可靠性要求比较高，要求支持事务
            2. 数据库事务的四大特性   
                1. 原子性
                2. 一致性
                3. 隔离性
                4. 持久性
            3. 事务隔离级别以及各级别下的并发访问问题
                1. 更新丢失 — mysql 所有事物隔离级别在数据库层面上可避免
                2. 脏读 （一个事务读取到另一个事务未提交的数据）— 已提交读事务隔离级别以上可避免
                3. 不可重复读 （不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据） — InnoDb 默认级别可以避免
                4. 幻读（事务不是独立执行时发生的一种现象） —Serializable 事务级别可避免
            4. InnoDB可重复隔离级别下如何避免幻读
                1. 表象：快照读（非阻塞读）— 伪MVCC
                2. 内在：next-key锁 （行锁 + gap锁）
        + 语法部分
            + Having 
                1. 通常与GROUP BY 子句一起使用
                2. where 过滤行，having 过滤组
                3. 出现在同一sql的顺序：where> group by > having 
    +   存储（文件系统）
    