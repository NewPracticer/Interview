### 数据库
+ 如何设计一个数据库
    +   程序实例
        +  存储管理
        +  缓存机制
        +  SQL解析
        +  日志管理
        +  权限划分
        +  容灾机制
        +  索引管理
            1. 为什么使用索引 -> 快速查询数据，不再使用全表扫描
            2. 什么信息能成为索引 ->  主键，唯一键，普通键
            3. 索引相关
                + 索引相关数据结构
                    1. 二叉查找树，有风险退化成链表
                    2. B-Tree
                    3. B+-Tree 磁盘读写代价低，查询效率更稳定，更有利于数据库的扫描
                    4. Hash索引 
                        + 优点
                            1. 查询效率高
                        + 缺点
                            1. 不能使用范围查询
                            2. 无法使用排序操作
                            3. 不能利用组合索引键进行查询
                            4. 不能避免表扫描
                        + 场景： 一般不用。对频繁查询的词汇在内存那种建立一个hashTable。对于key/value查询并发要求很高，用key-value内存数据库效果更好。
                +  密集索引和稀疏索引
                      1.  密集索引文件中的每个搜索码值都对应一个索引值
                      2.  稀疏索引文件只为索引码的某些值建立索引项
                +  如何定位并优化慢查询sql
                      1. 根据慢日志查询sql
                      2. 使用explain等工具分析sql
                      3. 修改sql或者尽量让sql走索引 
                + 正排索引和倒排索引。描述的是不同功能的索引
                    1. 倒排索引： 查询张三这个名字在哪个文档。词-》文档编号，索引格式《词，文档编号》
                    2. 正排索引： 查询文档里有哪些词汇。文档-》词。索引格式《文档，词》
                + Innodb的索引
                    1. 不用索引：时间复杂度是0(n)或者接受碎片
                    2. 红黑树索引 ：时间复杂度0(logn)。索引大小：1G行，索引大小1G×4(int) = 16G
                    3. B树 或 B+树索引 : 
                        1. 通过索引拿ID(二级索引)
                        2. 通过ID拿行的数据(聚簇索引)
                + 意义
                    1. 减少磁盘扫描
                    2. 减少排序和临时表
                    3. 随机I/O-》顺序I/O
                        
        +  锁管理
            1. MyIsam 与 Innodb 关于锁方面的区别是什么
                1. MyIsam 默认为表级锁，不支持行级锁
                    +  MyIsam 适用场景
                        1. 频繁执行全表count语句
                        2. 对数据进行增删改的频率不高，查询非常频繁
                        3. 没有事务
                2. InnoDB默认用的是行级锁，也支持表级锁
                    + InnoDB适合的场景
                        1. 数据增删改查相当频繁
                        2. 可靠性要求比较高，要求支持事务
            2. 数据库事务的四大特性   
                1. 原子性。操作不可再分
                2. 一致性。事务执行前后数据关系不被破坏。共享锁（读锁）。互斥锁（写锁）
                3. 隔离性。多个事务间执行隔离。（支持并发）
                4. 持久性
            3. 事务隔离级别以及各级别下的并发访问问题
                1. 更新丢失 — mysql 所有事物隔离级别在数据库层面上可避免
                2. 脏读 （一个事务读取到另一个事务未提交的数据）— 已提交读事务隔离级别以上可避免
                3. 不可重复读 （不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据） — InnoDb 默认级别可以避免
                4. 幻读（事务不是独立执行时发生的一种现象） —Serializable 事务级别可避免
            4. InnoDB可重复隔离级别下如何避免幻读
                1. 表象：快照读（非阻塞读）— 伪MVCC
                2. 内在：next-key锁 （行锁 + gap 间隙锁 ）
            5. 当前读 和快照读 
                1. 当前读 ：读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录，避免出现安全问题。（update、insert、delete 当前读）
                2. 快照读 ： 单纯的select操作。读取的是记录数据的可见版本（可能是过期的数据），不用加锁。
            6. 索引优化
                1. 经常被查询的区分度高的做索引
                2. 最左原则
                3. 回盘排序
                4. 覆盖索引
                5. 小表驱动大表
                6. 使用explain
                    1. system : 仅一行
                    2. const: 主键 or 唯一键的常量等值查询
                    3. eq_ret : 主键 or 唯一键 的扫描或关联查询
                    4. ref: 非唯一索引的常量等值查询
                    5. range ： 索引的范围查询
                    6. index ： 索引全查询
                    7. all ： 遍历表查询 
        + 语法部分
            + Having 
                1. 通常与GROUP BY 子句一起使用
                2. where 过滤行，having 过滤组
                3. 出现在同一sql的顺序：where> group by > having 
        +   存储（文件系统）
            + 行存储与列存储 （行存储更适合处理事务，列存储更适合处理查询）
                1. 更新一行的多个值。行，一行数据。列，多列数据
                2. 添加一行数据。行，一行数据。列，多列数据
                3. 事务。行，锁一行数据。列，锁对应的列
            + mysql: 行存储
            + mongdb: 文档存储：存储一个JSON(BSCNI)文档，或者一个文本文档
                 
    
                
            
                
            
    