### Redis
+ 从海量key里查询出某一固定前缀的key
    1. KeysPattern: 查找所有符合给定模式pattern的key
        1. keys指令一次性返回所有匹配的key
        2. 键的数量过大 会使服务器卡顿
    2. 使用SCAN 命令 
        1. 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
        2. 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历 
        3. 不保证每次执行都返回某个给定数量的元素，支持模糊查询
        4. 一次返回的数量不可控，只能是大概率符合count
+ 如何通过Redis实现分布式锁
    + 分布式锁需要解决的问题
        1. 互斥性
        2. 安全性
        3. 死锁 
        4. 容错 
    + Redis的实现
        1. SETNX key value 如果key不存在，则创建并赋值 （原子性无法实现）
            1. 设置expire ，设置过期时间，解决SETNX长期有效的问题
        2. SET key value [EX seconds] [PX miliseconds] [NX|XX]
            1. EX second ：设置键的过期时间为second 秒
            2. PX milisecond:设置键的过期时间为milisecond 毫秒
            3. NX :只在键不存在时，才对键进行设置操作。
            4. XX ：只在键已经存在时，才对键进行设置操作
            5. SET操作成功完成时，返回OK，否则返回nil 
+ 如何使用Redis 实现异步队列 
    1. 使用List作为队列，RPUSH生产消息，LPOP消费消息
        1. 缺点：没有等待队列里。有值就直接消费
        2. 弥补：可以通过在应用层引入sleep机制去调用LPOP重试
    2. BLPOP  ：阻塞队列有消息或者超时 
        1. 缺点: 只能供一个消费消费
    3. pub/sub: 主题订阅者模式
        1. 发送者（pub）发送消息，订阅者（sub）接受消息，订阅者可以订阅任意数量的频道
        2. 缺点：消息的发布是无状态的，无法保证可达。
+ Redis 持久化
    +  RDB(快照)持久化：保存某个时间点的全量数据快照
        1. SAVE: 阻塞Redis的服务器进程，直到RDB 文件被创建完毕
        2. BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程   
        3. 自动化触发RDB持久化的方式
            1. 根据redis.conf配置里面的SAVE m n 定时出发
            2. 主从复制时，主节点自动触发
            3. 执行debug reload
            4. 执行shutdown且没有开启AOF持久化
        4. 缺点
            1. 内存数据的全量同步，数据量会由于IO而严重影响性能
            2. 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据
    + AOF 持久化 ：记录下除了查询以外的所有变更数据状态的指令。以append的形式追击保存到AOF文件中（增量）
        1. 日志重写解决AOF文件大小不断增大的问题
            1. 调用fork(),创建一个子进程
            2. 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
            3. 主进程持续将新的变动同时写到内存和原来的AOF里
            4. 主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动
            5. 使用新的AOF文件替换掉旧的AOF文件
        2. 缺点： 文件体积过大，恢复时间长
    + RDB-AOF混合持久化方式。BGSAVE做镜像全量持久化，AOF做增量数据
+ Pipline
    1. Pipline批量执行命令，节省多次IO往返时间
    2. 有顺序依赖的指令建议分批分送
+ 同步机制
    + 全同步
        1. Slave发送sync命令到master
        2. Master启动一个后台进程，将Redis中的数据快照保存到文件中
        3. Master将保存数据快照期间接收到的写命令缓存起来
        4. Master完成写文件操作后，将该文件发送给Salve.
        5. 使用新的AOF文件替换掉旧的AOF文件
        6. Master将这期间收集的增量写命令发送给Slave端
    + 增量同步过程
        1.  Master接收到用户的操作指令，判断是否需要传播到Slave
        2. 将操作记录追加到AOF文件中
        3. 将操作传播到其他Slave: 1、对齐主从库 2、 往响应缓存写入指令
        4. 将缓存中的数据发送给Slave
+ Redis Sentinel
    1. 解决主从同步Master宕机后的主从切换问题
        1. 监控：检查主从服务器是否运行正常
        2. 提醒：通过API 向管理云或者其他应用程序发送故障通知
        3. 自动故障迁移：主从切换
+ Redis的集群原理
    1. 分片：按照某种规则去划分数据，分散存储在多个节点上
    2. 一致性哈希算法。将哈希空间组织成虚拟的圆环。
 