### 缓存
+ 缓存
   + 缓存是什么。加速数据访问的存储
   + 读写流程设计
     + 读： 关注穿透路径。穿透率
        + 穿透： 数据不存在 。
            1. 尝试设置无效标志位代表数据不存在到redis
        + 击穿： 同一数据击穿到数据库
        + 雪崩： 不同数据击穿到数据库
     + 写： 
        1. 写入穿透。双写缓存和存储
        2. 回写
            1. 先写缓存
            2. 延迟写入存储
                1. 按时延迟
                2. 缓冲延迟
                3. 其他事件触发
   + 缓存条目的设计：本质是数据结构的设计
   + 缓存置换策略
      + 空间有限，先到先得
      + 空间有限，保留热数据，移除冷数据
         + 冷数据
            1. 最近最少使用: 在每个缓存条目中增加频次数据
            2. 最近最近未使用：
               1. 每个缓存条目增加失效时间定期清理
               2. 模拟LRU,队列模拟LRU
               3. 用binary tree模拟LRU
   + 多级缓存举例： 布隆过滤器
### Redis 
+ String 类型 
    1. incr/decr/
    2. 事务：mult/exec
       1. 类似CAS的能力
          1. watch key 
          2. newValue = someJavaFunction
          3. MULT
          4. SET key $newValue
          5. EXEC
+ 从海量key里查询出某一固定前缀的key
    1. KeysPattern: 查找所有符合给定模式pattern的key
        1. keys指令一次性返回所有匹配的key
        2. 键的数量过大 会使服务器卡顿
    2. 使用SCAN 命令 
        1. 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
        2. 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历 
        3. 不保证每次执行都返回某个给定数量的元素，支持模糊查询
        4. 一次返回的数量不可控，只能是大概率符合count
+ 如何通过Redis简单实现分布式锁
    + 分布式锁需要解决的问题
        1. 互斥性
        2. 安全性
        3. 死锁 
        4. 容错 
    + Redis的实现
        1. SETNX key value 如果key不存在，则创建并赋值 （原子性无法实现）
            1. 设置expire ，设置过期时间，解决SETNX长期有效的问题
        2. SET key value [EX seconds] [PX miliseconds] [NX|XX]
            1. EX second ：设置键的过期时间为second 秒
            2. PX milisecond:设置键的过期时间为milisecond 毫秒
            3. NX :只在键不存在时，才对键进行设置操作。
            4. XX ：只在键已经存在时，才对键进行设置操作
            5. SET操作成功完成时，返回OK，否则返回nil 
+ 如何使用Redis 实现异步队列 
    1. 使用List作为队列，RPUSH生产消息，LPOP消费消息
        1. 缺点：没有等待队列里。有值就直接消费
        2. 弥补：可以通过在应用层引入sleep机制去调用LPOP重试
    2. BLPOP  ：阻塞队列有消息或者超时 
        1. 缺点: 只能供一个消费消费
    3. pub/sub: 主题订阅者模式
        1. 发送者（pub）发送消息，订阅者（sub）接受消息，订阅者可以订阅任意数量的频道
        2. 缺点：消息的发布是无状态的，无法保证可达。
+ Redis 持久化
    +  RDB(快照)持久化：保存某个时间点的全量数据快照。到期写。
        1. SAVE: 阻塞Redis的服务器进程，直到RDB 文件被创建完毕
        2. BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程   
        3. 自动化触发RDB持久化的方式
            1. 根据redis.conf配置里面的SAVE m n 定时出发
            2. 主从复制时，主节点自动触发
            3. 执行debug reload
            4. 执行shutdown且没有开启AOF持久化
        4. 缺点
            1. 内存数据的全量同步，数据量会由于IO而严重影响性能
            2. 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据
    + AOF 持久化 ：记录下除了查询以外的所有变更数据状态的指令。以append的形式追击保存到AOF文件中（增量）。到次数写。
        1. 日志重写解决AOF文件大小不断增大的问题
            1. 调用fork(),创建一个子进程
            2. 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
            3. 主进程持续将新的变动同时写到内存和原来的AOF里
            4. 主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动
            5. 使用新的AOF文件替换掉旧的AOF文件
        2. 缺点： 文件体积过大，恢复时间长
    + RDB-AOF混合持久化方式。BGSAVE做镜像全量持久化，AOF做增量数据
+ Pipline
    1. Pipline批量执行命令，节省多次IO往返时间
    2. 有顺序依赖的指令建议分批分送
+ 同步机制
    + 全同步
        1. Slave发送sync命令到master
        2. Master启动一个后台进程，将Redis中的数据快照保存到文件中
        3. Master将保存数据快照期间接收到的写命令缓存起来
        4. Master完成写文件操作后，将该文件发送给Salve.
        5. 使用新的AOF文件替换掉旧的AOF文件
        6. Master将这期间收集的增量写命令发送给Slave端
    + 增量同步过程
        1.  Master接收到用户的操作指令，判断是否需要传播到Slave
        2. 将操作记录追加到AOF文件中
        3. 将操作传播到其他Slave: 1、对齐主从库 2、 往响应缓存写入指令
        4. 将缓存中的数据发送给Slave
+ Redis Sentinel
    1. 解决主从同步Master宕机后的主从切换问题
        1. 监控：检查主从服务器是否运行正常
        2. 提醒：通过API 向管理云或者其他应用程序发送故障通知
        3. 自动故障迁移：主从切换
+ Redis的集群原理
    1. 分片：按照某种规则去划分数据，分散存储在多个节点上
    2. 一致性哈希算法。将哈希空间组织成虚拟的圆环。
+ Redis 数据结构 ：zset的结构。跳表+压缩表。
+ Redis 缓存淘汰策略
    1. lru: 最近最少使用的淘汰。allkeys：所有volatile 设置过期时间
    2. ttl ： 从已设置过期时间中挑选将要过期的淘汰
    3. random：数据中随机淘汰。allkeys: 所有volatile 设置过期时间
    4. no- enviction ： 禁止驱逐，直接报错
### Rocketmq
+ 组件
    1. name sever 命令查询服务器
    2. producer: 消息生产者
    3. message broker:消息队列
    4. consumer group :消费者组
    5. consumer ：消费者
    6. topic :主题
    7. partion：消息分片/队列
        

 