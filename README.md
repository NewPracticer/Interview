## Interview---面试

### 数据库
+ 如何设计一个数据库
    +   程序实例
        +  存储管理
        +  缓存机制
        +  SQL解析
        +  日志管理
        +  权限划分
        +  容灾机制
        +  索引管理
            1. 为什么使用索引 -> 快速查询数据，不再使用全表扫描
            2. 什么信息能成为索引 ->  主键，唯一键，普通键
            3. 索引相关
                + 索引相关数据结构
                    1. 二叉查找树，有风险退化成链表
                    2. B-Tree
                    3. B+-Tree 磁盘读写代价低，查询效率更稳定，更有利于数据库的扫描
                    4. Hash索引 
                        + 优点
                            1. 查询效率高
                        + 缺点
                            1. 不能使用范围查询
                            2. 无法使用排序操作
                            3. 不能利用组合索引键进行查询
                            4. 不能避免表扫描
                +  密集索引和稀疏索引
                      1.  密集索引文件中的每个搜索码值都对应一个索引值
                      2.  稀疏索引文件只为索引码的某些值建立索引项
                +  如何定位并优化慢查询sql
                      1. 根据慢日志查询sql
                      2. 使用explain等工具分析sql
                      3. 修改sql或者尽量让sql走索引 
        +  锁管理
            1. MyIsam 与 Innodb 关于锁方面的区别是什么
                1. MyIsam 默认为表级锁，不支持行级锁
                    +  MyIsam 适用场景
                        1. 频繁执行全表count语句
                        2. 对数据进行增删改的频率不高，查询非常频繁
                        3. 没有事务
                2. InnoDB默认用的是行级锁，也支持表级锁
                    + InnoDB适合的场景
                        1. 数据增删改查相当频繁
                        2. 可靠性要求比较高，要求支持事务
            2. 数据库事务的四大特性   
                1. 原子性
                2. 一致性
                3. 隔离性
                4. 持久性
            3. 事务隔离级别以及各级别下的并发访问问题
                1. 更新丢失 — mysql 所有事物隔离级别在数据库层面上可避免
                2. 脏读 （一个事务读取到另一个事务未提交的数据）— 已提交读事务隔离级别以上可避免
                3. 不可重复读 （不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据） — InnoDb 默认级别可以避免
                4. 幻读（事务不是独立执行时发生的一种现象） —Serializable 事务级别可避免
            4. InnoDB可重复隔离级别下如何避免幻读
                1. 表象：快照读（非阻塞读）— 伪MVCC
                2. 内在：next-key锁 （行锁 + gap锁）
        + 语法部分
            + Having 
                1. 通常与GROUP BY 子句一起使用
                2. where 过滤行，having 过滤组
                3. 出现在同一sql的顺序：where> group by > having 
    +   存储（文件系统）
    
### Redis
+ 从海量key里查询出某一固定前缀的key
    1. KeysPattern: 查找所有符合给定模式pattern的key
        1. keys指令一次性返回所有匹配的key
        2. 键的数量过大 会使服务器卡顿
    2. 使用SCAN 命令 
        1. 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
        2. 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历 
        3. 不保证每次执行都返回某个给定数量的元素，支持模糊查询
        4. 一次返回的数量不可控，只能是大概率符合count
+ 如何通过Redis实现分布式锁
    + 分布式锁需要解决的问题
        1. 互斥性
        2. 安全性
        3. 死锁 
        4. 容错 
    + Redis的实现
        1. SETNX key value 如果key不存在，则创建并赋值 （原子性无法实现）
            1. 设置expire ，设置过期时间，解决SETNX长期有效的问题
        2. SET key value [EX seconds] [PX miliseconds] [NX|XX]
            1. EX second ：设置键的过期时间为second 秒
            2. PX milisecond:设置键的过期时间为milisecond 毫秒
            3. NX :只在键不存在时，才对键进行设置操作。
            4. XX ：只在键已经存在时，才对键进行设置操作
            5. SET操作成功完成时，返回OK，否则返回nil 
+ 如何使用Redis 实现异步队列 
    1. 使用List作为队列，RPUSH生产消息，LPOP消费消息
        1. 缺点：没有等待队列里。有值就直接消费
        2. 弥补：可以通过在应用层引入sleep机制去调用LPOP重试
    2. BLPOP  ：阻塞队列有消息或者超时 
        1. 缺点: 只能供一个消费消费
    3. pub/sub: 主题订阅者模式
        1. 发送者（pub）发送消息，订阅者（sub）接受消息，订阅者可以订阅任意数量的频道
        2. 缺点：消息的发布是无状态的，无法保证可达。
    



