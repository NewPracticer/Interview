## Interview---面试

### 数据库
+ 如何设计一个数据库
    +   程序实例
        +  存储管理
        +  缓存机制
        +  SQL解析
        +  日志管理
        +  权限划分
        +  容灾机制
        +  索引管理
            1. 为什么使用索引 -> 快速查询数据，不再使用全表扫描
            2. 什么信息能成为索引 ->  主键，唯一键，普通键
            3. 索引相关
                + 索引相关数据结构
                    1. 二叉查找树，有风险退化成链表
                    2. B-Tree
                    3. B+-Tree 磁盘读写代价低，查询效率更稳定，更有利于数据库的扫描
                    4. Hash索引 
                        + 优点
                            1. 查询效率高
                        + 缺点
                            1. 不能使用范围查询
                            2. 无法使用排序操作
                            3. 不能利用组合索引键进行查询
                            4. 不能避免表扫描
                +  密集索引和稀疏索引
                      1.  密集索引文件中的每个搜索码值都对应一个索引值
                      2.  稀疏索引文件只为索引码的某些值建立索引项
                +  如何定位并优化慢查询sql
                      1. 根据慢日志查询sql
                      2. 使用explain等工具分析sql
                      3. 修改sql或者尽量让sql走索引 
        +  锁管理
            1. MyIsam 与 Innodb 关于锁方面的区别是什么
                1. MyIsam 默认为表级锁，不支持行级锁
                    +  MyIsam 适用场景
                        1. 频繁执行全表count语句
                        2. 对数据进行增删改的频率不高，查询非常频繁
                        3. 没有事务
                2. InnoDB默认用的是行级锁，也支持表级锁
                    + InnoDB适合的场景
                        1. 数据增删改查相当频繁
                        2. 可靠性要求比较高，要求支持事务
            2. 数据库事务的四大特性   
                1. 原子性
                2. 一致性
                3. 隔离性
                4. 持久性
            3. 事务隔离级别以及各级别下的并发访问问题
                1. 更新丢失 — mysql 所有事物隔离级别在数据库层面上可避免
                2. 脏读 （一个事务读取到另一个事务未提交的数据）— 已提交读事务隔离级别以上可避免
                3. 不可重复读 （不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据） — InnoDb 默认级别可以避免
                4. 幻读（事务不是独立执行时发生的一种现象） —Serializable 事务级别可避免
            4. InnoDB可重复隔离级别下如何避免幻读
                1. 表象：快照读（非阻塞读）— 伪MVCC
                2. 内在：next-key锁 （行锁 + gap锁）
        + 语法部分
            + Having 
                1. 通常与GROUP BY 子句一起使用
                2. where 过滤行，having 过滤组
                3. 出现在同一sql的顺序：where> group by > having 
    +   存储（文件系统）
    
### Redis
+ 从海量key里查询出某一固定前缀的key
    1. KeysPattern: 查找所有符合给定模式pattern的key
        1. keys指令一次性返回所有匹配的key
        2. 键的数量过大 会使服务器卡顿
    2. 使用SCAN 命令 
        1. 基于游标的迭代器，需要基于上一次的游标延续之前的迭代过程
        2. 以0作为游标开始一次新的迭代，知道命令返回游标0完成一次遍历 
        3. 不保证每次执行都返回某个给定数量的元素，支持模糊查询
        4. 一次返回的数量不可控，只能是大概率符合count
+ 如何通过Redis实现分布式锁
    + 分布式锁需要解决的问题
        1. 互斥性
        2. 安全性
        3. 死锁 
        4. 容错 
    + Redis的实现
        1. SETNX key value 如果key不存在，则创建并赋值 （原子性无法实现）
            1. 设置expire ，设置过期时间，解决SETNX长期有效的问题
        2. SET key value [EX seconds] [PX miliseconds] [NX|XX]
            1. EX second ：设置键的过期时间为second 秒
            2. PX milisecond:设置键的过期时间为milisecond 毫秒
            3. NX :只在键不存在时，才对键进行设置操作。
            4. XX ：只在键已经存在时，才对键进行设置操作
            5. SET操作成功完成时，返回OK，否则返回nil 
+ 如何使用Redis 实现异步队列 
    1. 使用List作为队列，RPUSH生产消息，LPOP消费消息
        1. 缺点：没有等待队列里。有值就直接消费
        2. 弥补：可以通过在应用层引入sleep机制去调用LPOP重试
    2. BLPOP  ：阻塞队列有消息或者超时 
        1. 缺点: 只能供一个消费消费
    3. pub/sub: 主题订阅者模式
        1. 发送者（pub）发送消息，订阅者（sub）接受消息，订阅者可以订阅任意数量的频道
        2. 缺点：消息的发布是无状态的，无法保证可达。
+ Redis 持久化
    +  RDB(快照)持久化：保存某个时间点的全量数据快照
        1. SAVE: 阻塞Redis的服务器进程，直到RDB 文件被创建完毕
        2. BGSAVE：Fork出一个子进程来创建RDB文件，不阻塞服务器进程   
        3. 自动化触发RDB持久化的方式
            1. 根据redis.conf配置里面的SAVE m n 定时出发
            2. 主从复制时，主节点自动触发
            3. 执行debug reload
            4. 执行shutdown且没有开启AOF持久化
        4. 缺点
            1. 内存数据的全量同步，数据量会由于IO而严重影响性能
            2. 可能会因为Redis挂掉而丢失从当前至最近一次快照期间的数据
    + AOF 持久化 ：记录下除了查询以外的所有变更数据状态的指令。以append的形式追击保存到AOF文件中（增量）
        1. 日志重写解决AOF文件大小不断增大的问题
            1. 调用fork(),创建一个子进程
            2. 子进程把新的AOF写到一个临时文件里，不依赖原来的AOF文件
            3. 主进程持续将新的变动同时写到内存和原来的AOF里
            4. 主进程获取子进程重写AOF的完成信号，往新AOF同步增量变动
            5. 使用新的AOF文件替换掉旧的AOF文件
        2. 缺点： 文件体积过大，恢复时间长
    + RDB-AOF混合持久化方式。BGSAVE做镜像全量持久化，AOF做增量数据
+ Pipline
    1. Pipline批量执行命令，节省多次IO往返时间
    2. 有顺序依赖的指令建议分批分送
+ 同步机制
    + 全同步
        1. Slave发送sync命令到master
        2. Master启动一个后台进程，将Redis中的数据快照保存到文件中
        3. Master将保存数据快照期间接收到的写命令缓存起来
        4. Master完成写文件操作后，将该文件发送给Salve.
        5. 使用新的AOF文件替换掉旧的AOF文件
        6. Master将这期间收集的增量写命令发送给Slave端
    + 增量同步过程
        1.  Master接收到用户的操作指令，判断是否需要传播到Slave
        2. 将操作记录追加到AOF文件中
        3. 将操作传播到其他Slave: 1、对齐主从库 2、 往响应缓存写入指令
        4. 将缓存中的数据发送给Slave
+ Redis Sentinel
    1. 解决主从同步Master宕机后的主从切换问题
        1. 监控：检查主从服务器是否运行正常
        2. 提醒：通过API 向管理云或者其他应用程序发送故障通知
        3. 自动故障迁移：主从切换
+ Redis的集群原理
    1. 分片：按照某种规则去划分数据，分散存储在多个节点上
    2. 一致性哈希算法。将哈希空间组织成虚拟的圆环。
### Linux 
+ Linux的体系结构
    1. 体系结构主要分为用户态（用户上层活动）和内核态
    2. 内核：本质是一段管理计算机硬件设备的程序
    3. 系统调用：内核的访问接口，是一种能再简化的操作
    4. 公用函数库：系统调用的组合拳
+ 找到特定文件
    1. find  在指定目录下查找文件
+ 检索文件内容
    1. grep: 查找文件里符合条件的字符串
    2. 管理操作符 | ： 可将指令链接起来，前一个指令的输出作为后一个指令的输入
+ 对文件内容统计
    1. awk : 一次读取一行文本，按输入分隔符进行切片，切成多个组成部分
+ 批量替换文件内容
    1. sed: 流编辑器 
### Java部分
+ 平台无关性
    1. Java源码首先被编译成字节码，再由不同平台的JVM进行解析，Java语言在不同的平台上运行时不需要进行重新编译，Java虚拟机在执行字节码的时候，把字节码转换成具体平台上的机器指令
+ 类从编译到执行的过程
    1. 编译器将Robot.java源文件编译为Robot.class字节码文件。
    2. ClassLoader 将字节码转换为JVM中的Class<Robot>对象
    3. JVM利用Class<Robot>对象实例化为Robot对象
+ JVM
    1. classloader:依据特定格式，加载class文件到内存
        + ClassLoader负责通过将Class文件里的二进制数据流装载进系统，然后交给Java虚拟机进行连接、初始化等操作。
        + 种类
            1. BootStrapClassLoader ：加载核心库 
            2. ExtClassLoader ： 加载扩展库
            3. AppClassLoader:   加载程序所在目录
            4. 自定义ClassLoader : 定制化加载 
        + 双亲委派机制
            1. 自底向上检查类是否已经加载
            2. 自顶向下尝试加载类 
                1. BootstrpClassLoader
                2. ExtensinClassLoader
                3. AppClassLoader
                4. CustomClassLoader
                
    2. Execution Engine: 对命令进行解析 
    3. Native Interface ：融合不同开发语言的原生库为java所用
    4. Runtime data Area： jvm 内存运行模型

