### 场景方案

#### 电商场景方案 
+ 电商场景特点
    1. CA 要求高，P也有要求
+ 架构
    + 流量入口
        1. H5 -(访问静态资源)-> CDN -(回源)-> nginx静态资源站服务器 -> 磁盘文件
        2. -(访问动态请求)-> CDN  -(公网IP)-> LVS
        3. --> nginx反向代理服务器
    + 服务治理
        1. nacos 
        2. 商品服务(Springboot),交易服务（Springboot）
    + 数据选型
        1. mysql ,es，Redis
    + 领域模型
        + 商品的领域模型
            + 商品基础模型（商品id,商品名，商家id）
            + 商品主信息
                1. 运费模型，包邮，运费计算
                2. 类目模型，类目id，类目树
                3. 品牌模型，品牌id，品牌名
            + 商品交易信息
                1. 销售模型，销售数量
                2. 库存模型，库存数量，分仓
            + 价格模型，价格计价，价格类型
            + 详情模型，详情内容
        +  交易的领域模型（下单支付）
            + 业务单 （订单id,订单内容，金额）
            + 主子商品单 （业务子单，子单id，商品id，商品数量，金额）
            + 支付单 （支付单id，支付工具类型，金额）
            + 营销工具 (营销工具单，优惠券id，活动id，金额) 
    + 业务流程
        + 商品服务
            + 查询商品主信息 -> redis 
               1. 商家后台更新商品信息到mysql，同时异步更新redis 缓存
            + 查询商品交易信息  -> redis 
               1. 交易系统发生交易时，库存/销量更新到队列，同时队列异步更新到redis 
        + 交易系统(支付请求)
            1. 价格计算校验（商品系统）
            2. 减库存（商品系统）
            3. 运费计算(商品系统)
            4. 优惠券核销（营销系统）
            5. 发起支付（支付系统对接网关）
            6. 支付下单（如支付宝，微信）
                1. 支付成功（支付宝，微信回调）--> 交易系统
                    1. 加销量（支付宝）
                1. 支付失败 （支付宝，微信回调）--> 交易系统
                    1. 回滚库存 （商品系统）
                    2. 回滚消费券（营销系统）
            7. 定时任务（订单超时）
        
+ 减库存
   + 压力点
      1. 不希望每次减库存操作都写DB
      2. 不希望每次读取库存都通过DB
   + 方案( [服务无状态](https://www.redhat.com/zh/topics/cloud-native-apps/stateful-vs-stateless)，批量写入，最终一致性)
      1. 库存服务
      2. Redis(key/value)库存
      3. 库存变更记录（Worker）
      4. 更新库存DB 
+ 秒杀 
   + 特点
      1. 瞬时流量大
      2. 读多写少
      3. 实时性要求高
   + 难点
      1. 减少DB命中：缓存，缓冲
      2. 需要反欺诈 
      3. 需要削峰： MQ消息队列
      4. 缓存一致性的实现：例如预减库存，用户下单后保留一段时间，然后释放
+ 下单、支付
   + 难点
        + 订单表通常很大 —> 水平拆分
        + 订单需要支持的业务非常多
            1. 订单状态变化（状态机）需要的资源较多
            2. 订单表访问非常频繁
            3. 需要通知的业务方很多
   + 策略
       1. 缓冲
       2. 缓冲设计
       3. 最终一致性
   + 方案
       1. 下单
           1. Redis订单（userid/order）
               1. 订单状态机
                    1. DB
           1. 订单队列
               1. DB
   + 交易一致性问题
       + 重复支付 (发起支付时，插入交易记录到数据库，并且设置状态为初始化，支付成功更新交易记录status 为成功)
            1. 防重操作 
                1. select * from order_info where id =""20211020"
                2. java代码判断 status == "初始" 执行第3步否则直接返回
                3. update order_info set status = "成功" where id = "20211020"并且发货
           2. 防重幂等操作 悲观锁
               1. begin transaction
               2. select * from order_info where id = "20211020" for update 加库存锁
               3. java代码判断 status == "初始" 执行第4步，否则直接返回rollback
               4. update order_info set status =‘成功’where id = '20211020',并且发货
               5. commit
           3. 防重幂等操作 乐观锁
               1. begin transaction
               2. select * from order_info where id = "20211020" 
               3. java代码判断 status == "初始" 执行第4步，否则直接返回rollback
               4. update order_info set status =‘成功’where id = '20211020' and status = ‘初始’,并且发货
               5. commit
   + 分布式事务
       1. 二阶段提交 （强一致性保证） prepare -> ack -> commit  (每个节点都如此操作)
       2. 异步确保型 
          1. 采用异步消息的方式确保事务可以最终一致
          2. 交易表
          3. fail支付失败待回滚 --> 发送消息 到 消息中间件 
            1. 优惠券退回 （营销系统）
            2. 库存回退 （商品系统）
       3. 事务型消息
          1. begin transaction 
          2. send prepare消息 到消息中间件 
          3. 执行本地事务 
          4. 执行本地commit
          5. send commit消息 
          6. 投递到消费方
       4. TCC 型。 try，catch，cancel
+ 缓存
   1. 端缓存
   2. 代理缓存
   3. CDN
   4. 分布式缓存
+ 单元化技术
   1. 多活
      1. 两地三中心：生产、同城灾备、异地灾备。  
   2. 灾备的处理方案
      1. 降级
      2. 限流
      3. 切流量     
    
   
        